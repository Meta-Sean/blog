{"title":"Micrograd ðŸ”§","markdown":{"yaml":{"title":"Micrograd ðŸ”§","author":"Terps","date":"2023-09-15","categories":["jupyter"],"theme":"minty","image":"image.jpg","highlight-style":"atom-one"},"headingText":"A blog implementation of Andrej Karpathy's [micrograd video](https://youtu.be/VMj-3S1tku0)","containsRefs":false,"markdown":"\n\n\n\n> Spelled-out intro to neural networks and backpropagation\n \n\n### Work in progress will continually add to this blog\n\n<a id=content></a>\n**Content:**\n### 1. [Derivative of a function](#1)\n### 2. [Core Value Object](#2)\n### 3. [Manual Backpropagation](#3)\n### 4. [Backward function](#4)\n### 5. [More operations](#5)\n### 6. [Pytorch](#6)\n\n<a id=1></a>\n# [Lets get an intuitive understanding of what a derivative is](#content)\n\nLets use a simple quadratic function as an example <br />\n<br/>\n## $f(x) = 3x^2 - 4x + 5$\n\n\nTake a look at the shape of the function, we can expect a parabola since we know its a quadratic function \n\nWe know want to think through what is the derivative of this function at different points x, let refresh with the definition of a derivative \n## $f'(x) = lim_{h \\to 0} \\frac{f(x+h)-f(x)}{h}$ \n\n\nYou are basically trying to see the level of sensitivty the function responds with by bumping any x value at any point slightly by this small number h </br>\nIntuitively how would you expect this function to respond if we nudged x = 3.0 by this small postitive number h? The amount the x value responds tells you the strength of the slope\n\nLets do a hacky implementation with more variables </br>\nLook at the function a*b + c in relation to the variables we assigned, imagine if you nudged each variables by a tiny amount would that result in our output being increased or decreased? </br>\nIf we were to slightly nudge each of our input varibles by the tiny amount h(amount approaching 0) we can approximate the instataneous rate of change by looking at the difference before and after over the amount we nudged by, this will give us the slope.\n\n\nLets do it with b now\n\n\nAnd c...\n\nHopefully this has helped build an inuitive sense of what this derivative is telling you about the function, but now we want to move to neural networks, which will be massive mathmatical expressions, so we need some structures to maintain these expressions, so we will build out a value object that can keep track of state and allow us to do expressions  \n\n<a id=2></a>\n# [Core Value Object](#content)\n\nWe use double underscore or dunder methods so python knows what to interally when we use operators such as print, +, -, * </br>\nSo when we call ```a + b``` above what is happening interally is ```a.__add__(b)``` with self as a and b as other. Similarly when we do ```a * b```, python is calling ```a.__mul__(b)``` \n\nCool so now we can do basic arthmetic now we need to add pointers to what see values produce other values and by what operations\n\nNow that we have the a way to store the parents, labels and operations we can visualize them with an expression graph, code below allows us to do that using a library called graphviz\n\n\n\nLets recap:\n- we are able to build out mathematical expressions using + and *\n- Added and tracked grad so we can calculate and update this state later when we do backpropagtion\n- Forward pass that produces output L and visualized\n- Now we want to do backpropagation\n\n<a id=3></a>\n# [Manual Backpropagation](#content)\n\nLets manually nudge the variable a and manually calculate the derivative of L with respect to a, lets create a gating function lol so we don't pollute the global scope. We can do this for each variable to calculate their derivative with respect to L\n\n![image.png](https://i.imgur.com/c53qrkN.png)\n\n### $L = d * f$\n### $\\frac{dL}{dd} =? f$\n### $lim_{h \\to 0} \\frac{(d+h)*f - d*f}{h}$ \n### $lim_{h \\to 0} \\frac{d*f + h*f - d*f}{h}$ \n### $lim_{h \\to 0} \\frac{h*f}{h}$ \n### $f$ \nSo we can see that d.grad is just the value of f which is -2.0 and by the property of symmetry f.grad is just the value of d which is 4.0, lets go ahead and manually set these\n\nSo we have just derived the derivates of f and d with respect to L in a step by step way, now next will uncover the core of backpropagation, we want derive the derivative of L with respect to c and e. </br>\nWe now know how L is sensitive to d and we know how e and c are sensitive to d, we can know put that together to figure out how L is sensitive to e and c.\n\n### If a variable z depends on the variable y, which itself depends on the variable x (that is, y and z are dependent variables), then z depends on x as well, via the intermediate variable y. In this case, the chain rule is expressed as\n# $\\frac{dz}{dx} = \\frac{dz}{dy} * \\frac{dy}{dx}$\nThe chain rule is fundamentally telling you how we chain these derivatives together correctly so to differentiate through a function composition we have to apply a multiplication of those derivatives </br>\n```The inuitive explanation here is that knowing the instantaneous rate of change of z with respect to y and y relative to x allows one to calculate the instantaneous rate of change of z```\n\n### If a car travels twice as fast as a bicyle and the cycle is four times as fast as a walking man then the car is 2 * 4 = 8 times faster than the man </br>\nWe know the derivative of $\\frac{dL}{dd}$ and $\\frac{dd}{dc}$ and want to find $\\frac{dL}{dc}$ the chain rule tells us that $\\frac{dL}{dc} = \\frac{dL}{dd} * \\frac{dd}{dc}$  \n$1.0 * -2.0 = -2.0$\n\nThe chain rule is telling us for plus nodes \"+\" we are just routing the gradient because the local derivative is just 1.0\n\n### Lets manually check our work by nudging c\n\nAs we expected c.grad equals -2.0*\n\n## Now we will recurse our way backwards again and going to do our second application of the chain rule\n### $\\frac{dL}{de} = -2.0$ </br>\n### $\\frac{de}{da} = b$ </br>\n### $\\frac{dL}{da} = \\frac{dL}{de} * \\frac{de}{da}$\n\nWe are multiplying the derivative of e with respect to L with the local gradients\n\nLets verify\n\nChecks out\n\n## We know know what back propagation is;  a recursive application of the chain rule backwards through the computational graph\n\n## Neuron Example\n\nOne step optimization\n\n![image.png](https://blog.liang2.tw/2015Talk-DeepLearn-CNN/pics/external/cs231n_note_neuron.png)\n\nFor our model of neurons we have input axis and these synapses that have weights on them so the w's are the weights and then the synapse interacts with the input multiplicatively so what flows to the cell body of this neuron is w times x but there's multiple inputs so there's many w times x's flowing into the cell body, the cell body also has some bias which is a sort of trigger happiness of this neuron, making it more or less prone to firing. Then we take it through an activation function which is generally some kinda of squashing function like a sigmoid or tanh. Lets go over an example of a tanh activation function \n\nYou can see that the inputs that come in get squashed here on the y axis, the function gets capped at 1.00 and -1.00\n\nWe need to add more operations to our Value class to be able to calculate our activation function tanh, lets just do a cheeky implementation of tanh on our value class for now\n\nAwesome n goes through tanh to produce the last output, our activation function is working great, now all we need to know is the derivative of tanh and we can use backpropagation.\n\nLets calculte the gradient of n\n\nNow we can easily get the gradients for x1w1x2w1, b, x1w1, x2w2 since we used addition as an operation the local derivatives are just 1 so we just take the value 0.5\n\nWe can know calculate the gradients for x2, w2, x1, and w1, but unlike the last gradients we used multiplication as our operation, so our local derivative is just the other term used in the operation so lets calculate the gradients\n\nNice!, we have manually used backpropagation to calculate our gradients, now lets implement a backward function for each operation\n\n<a id=4></a>\n# [Backward Function](#content)\n\nLets add a backward methods to our Value object for each operation that we can call to calculate our gradients for us using backpropagation\n\nWe initialize the gradient of o to 1.0, then call _backward to recursively calculate the gradients\n\nAwesome, this works great, we never want to call backward() on a node before we have calculated the gradients for everthing after it since it depends on their gradients. We will use topological sort which lays the graph such that all the edges go only from left to right.\n\n![img.png](https://miro.medium.com/max/1400/1*uMg_ojFXts2WZSjcZe4oRQ.png)\n\nOur Value objects are now ordered properly\n\n<a id=5></a>\n# [Lets implement this as a method in the Value object and add more operations](#content)\n\n<a id=6></a>\n# [Pytorch comparison](#content)\n\n![img.png](https://cs231n.github.io/assets/nn1/neural_net2.jpeg)\n\nSo how do we tune the weights to better predict the desired targets? We calculate a single number that measures the total performance of the neural net, this is called the loss.\n\nNow that we have called backward on the loss, we can take a look at the gradient of a single neuron in one of our layers to get a look on how it impacts our loss, this will be useful soon when we try to update our weights to decrease the loss\n\nThe gradient for this neuron is positive, so the weights is increasing our loss\n\nWe can now also call draw_dot on our loss, we can see the DAG has increased tremendously in compelexity \n\nWe can update our parameters by multiplying by substracting them by their gradients multiplied by a learning rate (the desired impact of the gradient has in updating our parameters, here we use 0.01 arbitrarily, but there are many techniques to find an optimal learning rate and to decay the rate as training continues, 0.1 is also a good rule of thumb, too big and you can overstep too small and its costly to train\n\nAfter updating our parameters we can confirm our loss decreased\n\nWhat we have done is gradient decent. Forward pass -> backward pass -> update the parameters. Now we just have to iterate this process, lets turn this manual process into a training loop\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"highlight-style":"atom-one","output-file":"2022-10-07-micrograd.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.0.38","theme":{"light":"flatly","dark":"darkly"},"title-block-banner":true,"title":"Micrograd ðŸ”§","author":"Terps","date":"2023-09-15","categories":["jupyter"],"image":"image.jpg"},"extensions":{"book":{"multiFile":true}}}}}